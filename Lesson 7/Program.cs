using System;


namespace ConsoleApp11
{
    class Program
    {
        static int boardSize = 8;//тут размер доски. если поставить стандартную 8, а коня в левый верхний угол, то будет всего лишь 8250733 попыток.
                                 //но вот если в произвольное место, то как повезет. Например, если в левый правый поставить, то 251825408 попыток.
                                 //А если в середину - 1307602521 попыток, но я успел обойти Борисовские пруды и вернуться домой.
        static int attemptedMoves = 0;
        //из абстрактной позиции любой доски (x,y) сферический конь в вакууме может прыгать по следующей траектории(буквами Г)
        //(x + 2, y + 1) - 2 вверх 1 вправо
        //(x + 1, y + 2) - 1 вверх 2 вправо
        //(x – 1, y + 2) - 1 вниз 2 вправо
        //(x – 2, y + 1) - 2 вниз 1 вправо
        //(x – 2, y – 1) - 2 вниз, 1 влево
        //(x – 1, y – 2) - 1 вниз, 2 влево
        //(x + 1, y – 2) - 1 вверх, 2 влево
        //(x + 2, y – 1) - 2 вверх, 1 влево

        //запишем в виде массива для горизонтали и вертикали:
        static int[] Horizontal = { 2, 1, -1, -2, -2, -1, 1, 2};
        static int[] Vertical = { 1, 2, 2, 1, -1, -2, -2, -1};
        //Вывод: сферический конь в вакууме двигается в 8 разных направлениях на любой ПЛОСКОЙ доске. Запомним это, для рекурсии пригодится!
        
        static int[,] Board = new int[boardSize, boardSize];//двумерный массив...слава Богу, мы не рассматриваем трехмерные шахматы из Стартрека xDDD. 
        static void Main(string[] args)
        {
            SearchSolution();
            Console.ReadLine();
        }

        static void SearchSolution()
        {
            //инициализируем доску, где не было коня. конь тут не проскакивал

            for (int i = 0; i < boardSize; i++)
            {
                for (int j = 0; j < boardSize; j++)
                {
                    //все ячейки, в которых не было коня надо покрасить. красим int.MaxValue, и почти ничем не рискуем. мб конечно есть какое-то одно решение для какой-нибудь доски,
                    //в котором кол-во решений == int.MaxValue, но во-первых, мы постареем и помудреем, пока оно будет найдено, а во-вторых...ну везде есть своя погрешность XDDD
                    Board[i, j] = int.MaxValue;
                }
            }

            //инициализация стартовой позиции коня по горизонатали(startX) и по вертикали(startY). Можно менять, чтоб проверить есть ли решения для разных вариантов
            int startX = 0;
            int startY = 0;

            Board[startX, startY] = 0;//ход номер ноль - стартовая позиция коня
            attemptedMoves = 0;//наш конь пока и не пытался скакать. стоит. думает. жует овес. ждет лыцаря Лиссандера.

            //рекурсивно обходим все возможные ходы, исходя из Horizontal и Vertical. Бэктрекаем, если тупик

            if (!CheckBoard(startX, startY, 1))//создаем рекурсивную всопогательную функцию, которая возвращает истину, если решения есть или ложь, если их нет, параметры - позиция по горизонтали, вертикали, количество ходов
            {
                Console.WriteLine($"No solution found for:{startX}, {startY}");
            }
            else
            {
                Print(Board);
                Console.WriteLine($"Total attempted moves: {attemptedMoves}");
            }


        }

        static bool CheckBoard(int x, int y, int moveCount)
        {
            attemptedMoves++; //увеличиваем число попыток на единицу.ну ибо Лиссандер же пытался...
            int k; //счетчик передвижений для следующих startX и startY
            //if (attemptedMoves > 500000000) return false;
            int next_x, next_y; //координаты для следующей рекурсии
            if (moveCount ==boardSize *boardSize) //а я так понимаю, это и решает дело. потому что у нас количество ходов должно совпасть с количеством всех клеток на доске.
                return true;//ну т.е. просто выходим отсюда, если клеток свободных клеток больше нет

            //нужно пройти по всем возможным ходам коня. как мы выяснили, их всего 8.см выше.
            for (k = 0; k < 8; k++) 
            {
                next_x = x + Horizontal[k]; //двигаемся по всем возможным вариантам ходов коня по горизонтали
                next_y = y + Vertical[k]; //двигаемся по всем возможным вариантам ходов коня по вертикали
                if (validUnit(next_x, next_y)) //а вдруг Лиссандер ускакал за пределы доски или двигается кругами?!
                {
                    Board[next_x, next_y] = moveCount; //1. если нашли безопасную клетку, т.е. такую, которая есть на доске и мы там еще не были, то однозначно можно прибавить кол-во ходов
                    if (CheckBoard(next_x, next_y, moveCount+1)) //повторяем упражнение
                        return true; //если все получилось - збс, возвращаем истину
                    else
                        Board[next_x, next_y] = int.MaxValue; //1. а вот если нет, то мы помечаем клетку как непосещенную. глаза в потолок, крутим пальчиками. ниче не было, нас там не было.
                }

            }
            return false;
        }


        static bool validUnit(int x, int y)
        {
            //1. мы не упали с доски
            //2. мы еще тут не были
            if (x >= 0 && x < boardSize && y >= 0 && y < boardSize && Board[x, y] == int.MaxValue)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        static void Print(int[,] boardToPrint)//ну это из методички.просто печатаем двумерный массив.копипаста.
        {
            for (int i = 0; i < boardSize; i++)
            {
                for (int j = 0; j < boardSize; j++)
                {
                    Console.Write(Board[i,j]+" "); 
                }
                Console.Write("\n");
            }
        }
    }

}

